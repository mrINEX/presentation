<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>React</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/league.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
				<section data-background="logo-reract.png" data-background-repeat="repeat" data-background-size="350px">
					<h1>React</h1>
					<h4>A JavaScript library for building user interfaces</h4>
					<p>
						<small>Website <a href="https://reactjs.org/">React</a> and <a href="https://github.com/facebook/react">GitHub</a></small>
					</p>
				</section>

				<section>
						<h2>Try React</h2>
						<small>React has been designed from the start for gradual adoption, and you can use as little or as much React as you need. Whether you want to get a taste of React, add some interactivity to a simple HTML page, or start a complex React-powered app</small>
						<small>API Reference: <a href="https://reactjs.org/docs/react-component.html">React.Component</a></small>
				</section>

				<section>
						<h3>Add React to a Website</h3>
						<small>Perhaps you only want to add some “sprinkles of interactivity” to an existing page. React components are a great way to do that. The majority of websites aren’t, and don’t need to be, single-page apps. With a few lines of code and no build tooling, try React in a small part of your website. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.</small></br>
				</section>

				<section>
					<h4>Step 1: Add a DOM Container to the HTML</h4>
					<small>First, open the HTML page you want to edit. Add an empty <div> tag to mark the spot where you want to display something with React. For example:</small>
					<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
						<!-- ... existing HTML ... -->
						&lt;div id="like_button_container"&gt;&lt;/div&gt;
						<!-- ... existing HTML ... -->	
						</code></pre>
					<small>We gave this &lt;div&gt; a unique id HTML attribute. This will allow us to find it from the JavaScript code later and display a React component inside of it.</small>
				</section>

				<section>
					<h4>Step 2: Add the Script Tags</h4>
					<small>Next, add three &lt;script&gt; tags to the HTML page right before the closing &lt;/body&gt; tag:</small>
					<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
<!-- Load React. -->
<!-- Note: when deploying, replace "development.js" with "production.min.js". -->
&lt;script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin&gt;&lt;/script&gt;
&lt;script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin&gt;&lt;/script&gt;

<!-- Load our React component. -->
&lt;script src="like_button.js"&gt;&lt;/script&gt;

&lt;/body&gt;
					</code></pre>
					<small>The first two tags load React. The third one will load your component code.</small>
				</section>

				<section>
					<h4>Step 3: Create a React Component</h4>
					<small>Create a file called like_button.js next to your HTML page. Open <a href="https://gist.githubusercontent.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js">this starter code</a> and paste it into the file you created. After the starter code, add two lines to the bottom of like_button.js:</small>
					<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
						// ... the starter code you pasted ...

						const domContainer = document.querySelector('#like_button_container');
						ReactDOM.render(e(LikeButton), domContainer);
						</code></pre>
					<small>These two lines of code find the &lt;div&gt; we added to our HTML in the first step, and then display our “Like” button React component inside of it.</small></br>
					<h4>That’s It!</h4> <small>There is no step four. You have just added the first React component to your website.</small>
				</section>

				<section>
					<h3>JavaScript Environment Requirements</h3>
					<small>React 16 depends on the collection types Map and Set. If you support older browsers and devices which may not yet provide these natively (e.g. IE < 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as core-js or babel-polyfill.</small>
					<small>A polyfilled environment for React 16 using core-js to support older browsers might look like:</small>
					<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
import 'core-js/es/map';
import 'core-js/es/set';

import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(
  &lt;h1>Hello, world!&lt;/h1>,
  document.getElementById('root')
);
						</code></pre>
					<small>React also depends on requestAnimationFrame (even in test environments).</small></br>
				</section>

				</section>
				<!-- Example of nested vertical slides -->
				<section>
					<section>
						<h5>The smallest React example looks like this:</h5>
						<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
							ReactDOM.render(
							  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
							  document.getElementById("root")
							);
						</code></pre>
						<h3>React particularity</h3>
							<small>Virtual DOM (Virtual Document Object Model)</small></br>
							<small>Using JSX (a combination of JavaScript and XML code)</small></br>
							<small>Babel (JavaScript compiler)</small></br>
							<small>SPA (Single-page Application)</small></br>
							<small>Reconciliation</small></br>
						<br>
						
					</section>

					<section>
						<h6>What is the Single-page Application?</h6>
						<small>A single-page application is an application that loads a single HTML page and all the necessary assets (such as JavaScript and CSS) required for the application to run. Any interactions with the page or subsequent pages do not require a round trip to the server which means the page is not reloaded. Though you may build a single-page application in React, it is not a requirement. React can also be used for enhancing small parts of existing websites with additional interactivity. Code written in React can coexist peacefully with markup rendered on the server by something like PHP, or with other client-side libraries. In fact, this is exactly how React is being used at Facebook.</small>
					</section>

					<section>
						<h6>What is the Babel?</h6>
						<small>Babel is a JavaScript compiler. Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments.</small>
					</section>

					<section>
						<h6>What is the JSX?</h6>
						<small>JSX is a syntax extension to JavaScript. It is similar to a template language, but it has full power of JavaScript. JSX gets compiled to React.createElement() calls which return plain JavaScript objects called “React elements”.</small>
					</section>

					<section>
						<h6>What is the Virtual DOM?</h6>
						<small>The virtual DOM (VDOM) is a programming concept where an ideal, or “virtual”, representation of a UI is kept in memory and synced with the “real” DOM by a library such as ReactDOM. This process is called reconciliation.
	
								This approach enables the declarative API of React: You tell React what state you want the UI to be in, and it makes sure the DOM matches that state. This abstracts out the attribute manipulation, event handling, and manual DOM updating that you would otherwise have to use to build your app.
	
								Since “virtual DOM” is more of a pattern than a specific technology, people sometimes say it to mean different things. In React world, the term “virtual DOM” is usually associated with React elements since they are the objects representing the user interface. React, however, also uses internal objects called “fibers” to hold additional information about the component tree. They may also be considered a part of “virtual DOM” implementation in React.
	
						</small>
					</section>

					<section>
						<h6>What is the Reconciliation?</h6>
						<small>When a component’s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called “reconciliation”.</small>
					</section>

					<section>
						<h6>Big O</h6>
						<small>When you use React, at a single point in time you can think of the render() function as creating a tree of React elements. On the next state or props update, that render() function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree.
							There are some generic solutions to this algorithmic problem of generating the minimum number of operations to transform one tree into another. However, the state of the art algorithms have a complexity in the order of O(n3) where n is the number of elements in the tree.
							If we used this in React, displaying 1000 elements would require in the order of one billion comparisons. This is far too expensive. Instead, React implements a heuristic O(n) algorithm based on two assumptions:</small></br>
						<small>1 Two elements of different types will produce different trees.</small></br>
						<small>2 The developer can hint at which child elements may be stable across different renders with a key prop.</small></br>
						<small>In practice, these assumptions are valid for almost all practical use cases.</small>

					</section>
				</section>

				<section>

					<section>
						<h3>Thinking in <h1>React</h1></h3><h4>React is the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.</h4>
						<small>One of the many great parts of React is how it makes you think about apps as you build them.</small>
					</section>

					<section>
						<h2>Rendering Elements</h2><h4>An element describes what you want to see on the screen</h4>
						<h6>Rendering an Element into the DOM</h6><small>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</small>
						</br>
						<h6>Updating the Rendered Element</h6><small>React elements are immutable. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</small>
						<h6>React Only Updates What’s Necessary</h6><small>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</small>
					</section>
					
					<section>
						<h2>Components and Props</h2><h4>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</h4>
						<h6>React is pretty flexible but it has a single strict rule:</h6><small>All React components must act like pure functions with respect to their props.</small>
						<small>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.</small>
						<h6>Extracting Components</h6><small>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component.</small>
					</section>

					<section>
						<h2>Conditional Rendering</h2><h4>In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.</h4>
						<small>Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them.</small>
						<h6>Preventing Component from Rendering</h6><small>In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return null instead of its render output. Returning null from a component’s render method does not affect the firing of the component’s lifecycle methods.</small>	
					</section>

					<section>
						<h2>Composition vs Inheritance</h2><h4>React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.</h4>
						<h6>So What About Inheritance?</h6><small>At Facebook, we use React in thousands of components, and we haven’t found any use cases where we would recommend creating component inheritance hierarchies.
							Props and composition give you all the flexibility you need to customize a component’s look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions.</small>	
					</section>
				</section>

				<section>
					<section>
						<h2>JSX</h2>
						<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
							const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
							</code></pre>
						<small>This funny tag syntax is neither a string nor HTML.
							It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.
							JSX produces React “elements”.</small>
						</br>
						<h6>Why JSX?</h6>
						<small>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.

								Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called “components” that contain both. React doesn’t require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</small>
					</section>

					<section>
						<h3>Embedding Expressions in JSX</h3>
						<small>In the example below, we declare a variable called name and then use it inside JSX by wrapping it in curly braces. You can put any valid JavaScript expression inside the curly braces in JSX.</small>
						<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
							const name = 'Josh Perez';
							const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;
								
							ReactDOM.render(
							  element,
							  document.getElementById('root')
							);
							</code></pre>
					</section>

					<section>
						<h3>JSX is an Expression Too</h3>
						<small>After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.
								This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions:</small>
						<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
							function getGreeting(user) {
							  if (user) {
								return &lt;h1>Hello, {formatName(user)}!&lt;/h1>;
							  }
							  return &lt;h1>Hello, Stranger.&lt;/h1>;
							}
							</code></pre>
					</section>
						
					<section>
						<h3>Specifying Attributes with JSX</h3>
						<small>You may use quotes to specify string literals as attributes:</small>
						<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
							const element = &lt;div tabIndex="0">&lt;/div>;
						</code></pre>

						<small>You may also use curly braces to embed a JavaScript expression in an attribute:</small>
						<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
							const element = &lt;img src={user.avatarUrl}>&lt;/img>;
						</code></pre>
						</br>
						<small>Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.</small>
					</section>

					<section>
							<h3>Specifying Children with JSX</h3>
							<small>If a tag is empty, you may close it immediately with />, like XML:</small>
							<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
								const element = &lt;img src={user.avatarUrl} />;
								</code></pre>
							</br>

							<small>JSX tags may contain children:</small>
							<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
							const element = (
							  &lt;div>
								&lt;h1>Hello!&lt;/h1>
								&lt;h2>Good to see you here.&lt;/h2>
							  &lt;/div>
							);
								</code></pre>
					</section>

					<section>
							<h3>JSX Represents JavaScript-Objects</h3>
							<small>Babel compiles JSX down to React.createElement() calls. These two examples are identical:</small>
							<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
									const element = (
										&lt;h1 className="greeting">
										  Hello, world!
										&lt;/h1>
									);
								</code></pre>
							<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
									const element = React.createElement(
										'h1',
										{className: 'greeting'},
										'Hello, world!'
									);
								</code></pre>
					</section>

					<section>
							<small>React.createElement() performs a few checks to help you write bug-free code but essentially it creates an object like this:</small>
							<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
// Note: this structure is simplified
const element = {
  type: 'h1',
  props: {
	className: 'greeting',
    children: 'Hello, world!'
  }
};
							</code></pre>
							<small>These objects are called “React elements”. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</small>
					</section>

				</section>

				<section>
					<section>
					<h2>Without JSX</h2><h4>Do I need to use JSX with React?</h4><h4>JSX is not a requirement for using React.</h4>
					<small>Each JSX element is just syntactic sugar for calling <code>React.createElement(component, props, ...children)</code>. So, anything you can do with JSX can also be done with just plain JavaScript.</small>
					</section>

					<section>
						<h4>this code written with JSX:</h4>
						<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
							class Hello extends React.Component {
							  render() {
								return &lt;div&gt;Hello {this.props.toWhat}&lt;/div&gt;
							  }
							}
								  
							ReactDOM.render(
							  &lt;Hello toWhat="World" /&gt;,
							  document.getElementById("root")
							);
						</code></pre>
					</section>

					<section>
						<h4>this code does not use JSX:</h4>
						<pre><code class="javascript" data-trim contenteditable style="font-size: 18px;">
						class Hello extends React.Component {
						  render() {
							return React.createElement("div", null, `Hello ${this.props.toWhat}`);
						  }
						}
								  
						ReactDOM.render(
						  React.createElement(Hello, {toWhat: "World"}, null),
						  document.getElementById("root")
						);
						</code></pre>
					</section>
				</section>

				<section style="text-align: left;">
					<section>
						<h1>THE END</h1>
						<p>
							- <a href="https://github.com/mrINEX">GitHub</a>
						</p>
					</section>
				</section>

			</div>

		</div>

		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
